#!/usr/bin/env pwsh
<#
.SYNOPSIS
    TiXL Vulnerability Scanner - Security vulnerability detection and analysis

.DESCRIPTION
    Scans NuGet packages for known security vulnerabilities using:
    - National Vulnerability Database (NVD)
    - GitHub Security Advisories
    - Custom vulnerability rules
    - Severity-based filtering and alerting

.PARAMETER ProjectPath
    Path to the solution or project file to scan

.PARAMETER Severity
    Minimum vulnerability severity to report (Low, Medium, High, Critical)

.PARAMETER OutputPath
    Directory to save vulnerability reports

.PARAMETER FailOnCritical
    Exit with error code if critical vulnerabilities are found

.PARAMETER ExportToCSV
    Export results to CSV format

.EXAMPLE
    .\vulnerability-scanner.ps1 -ProjectPath "TiXL.sln" -Severity "High"

.EXAMPLE
    .\vulnerability-scanner.ps1 -ProjectPath "TiXL.sln" -FailOnCritical -ExportToCSV
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory=$true)]
    [string]$ProjectPath,
    
    [Parameter(Mandatory=$false)]
    [ValidateSet("Low", "Medium", "High", "Critical")]
    [string]$Severity = "Medium",
    
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "./vulnerability-reports",
    
    [Parameter(Mandatory=$false)]
    [switch]$FailOnCritical,
    
    [Parameter(Mandatory=$false)]
    [switch]$ExportToCSV
)

# Global variables
$script:ScriptName = "TiXL Vulnerability Scanner"
$script:ScriptVersion = "1.0.0"
$script:StartTime = Get-Date
$script:ConfigPath = "$PSScriptRoot\..\config\vulnerability-rules.json"
$script:SupportedFormats = @(".csproj", ".sln")

# Initialize output directory
if (!(Test-Path $OutputPath)) {
    New-Item -Path $OutputPath -ItemType Directory -Force | Out-Null
}

$script:LogFile = Join-Path $OutputPath "vulnerability-scan.log"
$script:ReportFile = Join-Path $OutputPath "vulnerability-report.json"
$script:CSVFile = Join-Path $OutputPath "vulnerabilities.csv"

# Severity weights for filtering
$script:SeverityWeights = @{
    "Critical" = 4
    "High" = 3
    "Medium" = 2
    "Low" = 1
}

function Write-Log {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Message,
        [Parameter(Mandatory=$false)]
        [ValidateSet("INFO", "WARNING", "ERROR", "DEBUG")]
        [string]$Level = "INFO"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    
    Write-Host $logEntry
    $logEntry | Out-File -FilePath $script:LogFile -Append -Encoding UTF8
}

function Test-ProjectStructure {
    param([string]$ProjectPath)
    
    if (!(Test-Path $ProjectPath)) {
        throw "Project path not found: $ProjectPath"
    }
    
    $extension = [System.IO.Path]::GetExtension($ProjectPath).ToLower()
    if ($script:SupportedFormats -notcontains $extension) {
        throw "Unsupported project format: $extension. Supported formats: $($script:SupportedFormats -join ', ')"
    }
    
    return $true
}

function Get-PackageList {
    param([string]$ProjectPath)
    
    Write-Log "Extracting package list from $ProjectPath" "INFO"
    
    $packages = @()
    
    if ($ProjectPath.EndsWith('.sln')) {
        # Process solution file
        Write-Log "Processing solution file" "INFO"
        
        try {
            $projects = & dotnet sln "$ProjectPath" list 2>$null
            foreach ($projectPath in $projects) {
                if ($projectPath -and (Test-Path $projectPath)) {
                    $packages += Get-PackagesFromProject -ProjectPath $projectPath
                }
            }
        }
        catch {
            Write-Log "Failed to list projects in solution: $_" "ERROR"
            # Fall back to manual search
            $projectFiles = Get-ChildItem -Path (Split-Path $ProjectPath) -Filter "*.csproj" -Recurse
            foreach ($project in $projectFiles) {
                $packages += Get-PackagesFromProject -ProjectPath $project.FullName
            }
        }
    }
    else {
        # Process single project file
        $packages = Get-PackagesFromProject -ProjectPath $ProjectPath
    }
    
    Write-Log "Found $($packages.Count) packages to scan" "INFO"
    return $packages
}

function Get-PackagesFromProject {
    param([string]$ProjectPath)
    
    $packages = @()
    
    try {
        # Use dotnet list to get packages
        $listOutput = & dotnet list "$ProjectPath" package --include-transitive 2>$null
        
        if ($LASTEXITCODE -eq 0 -and $listOutput) {
            $currentProject = $null
            $projectName = [System.IO.Path]::GetFileNameWithoutExtension($ProjectPath)
            
            foreach ($line in $listOutput) {
                if ($line -match "^\s*([\w\.-]+)\s+([\d\.]+)\s+(.*)$") {
                    $packageName = $matches[1]
                    $version = $matches[2]
                    $license = $matches[3]
                    
                    $package = [PSCustomObject]@{
                        Name = $packageName
                        Version = $version
                        License = $license
                        Project = $projectName
                        ProjectPath = $ProjectPath
                        Source = "nuget"
                    }
                    
                    $packages += $package
                }
            }
        }
        else {
            Write-Log "Failed to get packages from $ProjectPath" "WARNING"
        }
    }
    catch {
        Write-Log "Error reading packages from $ProjectPath : $_" "ERROR"
    }
    
    return $packages
}

function Test-VulnerabilityDatabases {
    param(
        [string]$PackageName,
        [string]$Version
    )
    
    $vulnerabilities = @()
    
    # Test GitHub Security Advisories
    $githubVulns = Test-GitHubSecurityAdvisories -PackageName $PackageName -Version $Version
    $vulnerabilities += $githubVulns
    
    # Test National Vulnerability Database
    $nvdVulns = Test-NVDVulnerabilities -PackageName $PackageName -Version $Version
    $vulnerabilities += $nvdVulns
    
    # Test custom vulnerability rules
    $customVulns = Test-CustomVulnerabilityRules -PackageName $PackageName -Version $Version
    $vulnerabilities += $customVulns
    
    return $vulnerabilities
}

function Test-GitHubSecurityAdvisories {
    param(
        [string]$PackageName,
        [string]$Version
    )
    
    $vulnerabilities = @()
    
    try {
        Write-Log "Checking GitHub Security Advisories for $PackageName v$Version" "DEBUG"
        
        # GitHub Security Advisories API endpoint
        $apiUrl = "https://api.github.com/advisories?package_name=$PackageName&package_ecosystem=nuget"
        
        # Make request (in production, you'd use GitHub API token)
        $response = Invoke-RestMethod -Uri $apiUrl -Method Get -Headers @{
            "User-Agent" = "TiXL-Vulnerability-Scanner/1.0"
        } -ErrorAction SilentlyContinue
        
        if ($response -and $response.advisories) {
            foreach ($advisory in $response.advisories) {
                # Check if version is affected
                if (Test-VersionAffected -CurrentVersion $Version -VulnerableRange $advisory.vulnerable_version_range) {
                    $vulnerability = [PSCustomObject]@{
                        ID = $advisory.ghsa_id
                        Source = "GitHub Security Advisories"
                        Severity = Convert-GHSeverityToStandard $advisory.severity
                        CVSSScore = $advisory.cvss?.score
                        Description = $advisory.summary
                        FixedInVersion = $advisory.fixes_released_at
                        PublishedDate = $advisory.published_at
                        Package = $PackageName
                        Version = $Version
                        CVEs = $advisory.cves
                        References = $advisory.permalinks
                    }
                    
                    $vulnerabilities += $vulnerability
                }
            }
        }
    }
    catch {
        Write-Log "Error checking GitHub Security Advisories: $_" "WARNING"
    }
    
    return $vulnerabilities
}

function Test-NVDVulnerabilities {
    param(
        [string]$PackageName,
        [string]$Version
    )
    
    $vulnerabilities = @()
    
    try {
        Write-Log "Checking NVD for $PackageName v$Version" "DEBUG"
        
        # NVD API v2.0 endpoint
        $apiUrl = "https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=$PackageName&resultsPerPage=50"
        
        $response = Invoke-RestMethod -Uri $apiUrl -ErrorAction SilentlyContinue
        
        if ($response -and $response.vulnerabilities) {
            foreach ($vuln in $response.vulnerabilities) {
                $cve = $vuln.cve
                
                # Check if this CVE affects our package version
                if (Test-CVEAffectsPackage -CVE $cve -PackageName $PackageName -Version $Version) {
                    $vulnerability = [PSCustomObject]@{
                        ID = $cve.id
                        Source = "National Vulnerability Database"
                        Severity = Get-NVDSeverity $cve.metrics
                        CVSSScore = Get-CVSSScore $cve.metrics
                        Description = Get-CVEDescription $cve.descriptions
                        FixedInVersion = $null  # NVD doesn't always provide fix versions
                        PublishedDate = $cve.published
                        Package = $PackageName
                        Version = $Version
                        CVEs = @($cve.id)
                        References = $cve.references
                    }
                    
                    $vulnerabilities += $vulnerability
                }
            }
        }
    }
    catch {
        Write-Log "Error checking NVD: $_" "WARNING"
    }
    
    return $vulnerabilities
}

function Test-CustomVulnerabilityRules {
    param(
        [string]$PackageName,
        [string]$Version
    )
    
    $vulnerabilities = @()
    
    try {
        if (Test-Path $script:ConfigPath) {
            $config = Get-Content $script:ConfigPath | ConvertFrom-Json
            
            if ($config.customRules) {
                foreach ($rule in $config.customRules) {
                    if ($rule.packageName -eq $PackageName) {
                        # Check version range
                        if (Test-VersionInRange -Version $Version -Range $rule.versionRange) {
                            $vulnerability = [PSCustomObject]@{
                                ID = $rule.id
                                Source = "Custom Rule"
                                Severity = $rule.severity
                                CVSSScore = $rule.cvssScore
                                Description = $rule.description
                                FixedInVersion = $rule.fixedInVersion
                                PublishedDate = $rule.publishedDate
                                Package = $PackageName
                                Version = $Version
                                CVEs = @()
                                References = @($rule.referenceUrl)
                            }
                            
                            $vulnerabilities += $vulnerability
                        }
                    }
                }
            }
        }
    }
    catch {
        Write-Log "Error checking custom vulnerability rules: $_" "WARNING"
    }
    
    return $vulnerabilities
}

function Test-VersionAffected {
    param(
        [string]$CurrentVersion,
        [string]$VulnerableRange
    )
    
    # Simplified version checking - in production, use a proper version range parser
    # For now, just check if the version contains the word "all" or check exact match
    
    if ($VulnerableRange -eq "*" -or $VulnerableRange -eq "all") {
        return $true
    }
    
    # Handle exact version matches
    if ($VulnerableRange -eq $CurrentVersion) {
        return $true
    }
    
    # Handle version ranges like ">= 1.0.0 < 2.0.0"
    if ($VulnerableRange -match "([<>]=?)\s*([\d\.]+)") {
        $operator = $matches[1]
        $version = $matches[2]
        
        try {
            $currentVer = [version]$CurrentVersion
            $targetVer = [version]$version
            
            switch ($operator) {
                ">="  { return $currentVer -ge $targetVer }
                ">"   { return $currentVer -gt $targetVer }
                "<="  { return $currentVer -le $targetVer }
                "<"   { return $currentVer -lt $targetVer }
            }
        }
        catch {
            Write-Log "Error parsing version range: $VulnerableRange" "WARNING"
        }
    }
    
    return $false
}

function Test-VersionInRange {
    param(
        [string]$Version,
        [string]$Range
    )
    
    # Same logic as Test-VersionAffected
    return Test-VersionAffected -CurrentVersion $Version -VulnerableRange $Range
}

function Convert-GHSeverityToStandard {
    param([string]$GHSeverity)
    
    switch ($GHSeverity.ToLower()) {
        "critical" { return "Critical" }
        "high"     { return "High" }
        "moderate" { return "Medium" }
        "low"      { return "Low" }
        default    { return "Medium" }
    }
}

function Get-NVDSeverity {
    param($Metrics)
    
    # Get severity from CVSS v3 or v2
    if ($Metrics.cvssMetricV31 -and $Metrics.cvssMetricV31.Count -gt 0) {
        $cvss = $Metrics.cvssMetricV31[0].cvssData
        return Get-SeverityFromCVSS $cvss.baseScore
    }
    elseif ($Metrics.cvssMetricV30 -and $Metrics.cvssMetricV30.Count -gt 0) {
        $cvss = $Metrics.cvssMetricV30[0].cvssData
        return Get-SeverityFromCVSS $cvss.baseScore
    }
    elseif ($Metrics.cvssMetricV2 -and $Metrics.cvssMetricV2.Count -gt 0) {
        $cvss = $Metrics.cvssMetricV2[0].cvssData
        return Get-SeverityFromCVSS $cvss.baseScore
    }
    
    return "Medium"
}

function Get-SeverityFromCVSS {
    param([decimal]$Score)
    
    if ($Score -ge 9.0) { return "Critical" }
    elseif ($Score -ge 7.0) { return "High" }
    elseif ($Score -ge 4.0) { return "Medium" }
    else { return "Low" }
}

function Get-CVSSScore {
    param($Metrics)
    
    if ($Metrics.cvssMetricV31 -and $Metrics.cvssMetricV31.Count -gt 0) {
        return $Metrics.cvssMetricV31[0].cvssData.baseScore
    }
    elseif ($Metrics.cvssMetricV30 -and $Metrics.cvssMetricV30.Count -gt 0) {
        return $Metrics.cvssMetricV30[0].cvssData.baseScore
    }
    elseif ($Metrics.cvssMetricV2 -and $Metrics.cvssMetricV2.Count -gt 0) {
        return $Metrics.cvssMetricV2[0].cvssData.baseScore
    }
    
    return $null
}

function Get-CVEDescription {
    param($Descriptions)
    
    if ($Descriptions -and $Descriptions.Count -gt 0) {
        $englishDesc = $Descriptions | Where-Object { $_.lang -eq "en" }
        if ($englishDesc) {
            return $englishDesc[0].value
        }
        return $Descriptions[0].value
    }
    
    return "No description available"
}

function Test-CVEAffectsPackage {
    param(
        $CVE,
        [string]$PackageName,
        [string]$Version
    )
    
    # Check if the CVE mentions our package
    $cveText = "$($CVE.id) $($CVE.descriptions | ForEach-Object { $_.value })"
    return ($cveText -match $PackageName)
}

function Filter-VulnerabilitiesBySeverity {
    param(
        [array]$Vulnerabilities,
        [string]$MinimumSeverity
    )
    
    $minimumWeight = $script:SeverityWeights[$MinimumSeverity]
    
    return $Vulnerabilities | Where-Object {
        $script:SeverityWeights[$_.Severity] -ge $minimumWeight
    }
}

function Export-VulnerabilityReport {
    param(
        [array]$AllVulnerabilities,
        [string]$OutputPath
    )
    
    Write-Log "Exporting vulnerability report" "INFO"
    
    $reportData = @{
        ScanInfo = @{
            Timestamp = $script:StartTime
            Duration = (Get-Date) - $script:StartTime
            Version = $script:ScriptVersion
            ProjectPath = $ProjectPath
            MinimumSeverity = $Severity
        }
        Summary = @{
            Total = $AllVulnerabilities.Count
            Critical = ($AllVulnerabilities | Where-Object { $_.Severity -eq "Critical" }).Count
            High = ($AllVulnerabilities | Where-Object { $_.Severity -eq "High" }).Count
            Medium = ($AllVulnerabilities | Where-Object { $_.Severity -eq "Medium" }).Count
            Low = ($AllVulnerabilities | Where-Object { $_.Severity -eq "Low" }).Count
        }
        Vulnerabilities = $AllVulnerabilities
        Sources = @{
            GitHub = ($AllVulnerabilities | Where-Object { $_.Source -eq "GitHub Security Advisories" }).Count
            NVD = ($AllVulnerabilities | Where-Object { $_.Source -eq "National Vulnerability Database" }).Count
            Custom = ($AllVulnerabilities | Where-Object { $_.Source -eq "Custom Rule" }).Count
        }
    }
    
    # Export JSON report
    $reportData | ConvertTo-Json -Depth 10 | Out-File -FilePath $script:ReportFile -Encoding UTF8
    
    # Export CSV if requested
    if ($ExportToCSV) {
        Export-VulnerabilityCSV -Vulnerabilities $AllVulnerabilities -OutputPath $script:CSVFile
    }
    
    # Generate markdown summary
    Export-VulnerabilityMarkdown -ReportData $reportData -OutputPath (Join-Path $OutputPath "vulnerability-summary.md")
    
    Write-Log "Vulnerability report exported to: $OutputPath" "INFO"
}

function Export-VulnerabilityCSV {
    param(
        [array]$Vulnerabilities,
        [string]$OutputPath
    )
    
    $csvData = $Vulnerabilities | Select-Object @(
        @{Name="Package"; Expression={$_.Package}}
        @{Name="Version"; Expression={$_.Version}}
        @{Name="VulnerabilityID"; Expression={$_.ID}}
        @{Name="Severity"; Expression={$_.Severity}}
        @{Name="CVSSScore"; Expression={$_.CVSSScore}}
        @{Name="Source"; Expression={$_.Source}}
        @{Name="Description"; Expression={$_.Description}}
        @{Name="FixedInVersion"; Expression={$_.FixedInVersion}}
        @{Name="PublishedDate"; Expression={$_.PublishedDate}}
        @{Name="CVEs"; Expression={$_.CVEs -join ";"}}
    )
    
    $csvData | Export-Csv -Path $OutputPath -NoTypeInformation -Encoding UTF8
}

function Export-VulnerabilityMarkdown {
    param(
        $ReportData,
        [string]$OutputPath
    )
    
    $markdown = @"
# TiXL Vulnerability Scan Report

**Generated**: $($ReportData.ScanInfo.Timestamp.ToString("yyyy-MM-dd HH:mm:ss"))
**Duration**: $($ReportData.ScanInfo.Duration.TotalSeconds.ToString("F2")) seconds
**Version**: $($ReportData.ScanInfo.Version)
**Project**: $($ReportData.ScanInfo.ProjectPath)
**Minimum Severity**: $($ReportData.ScanInfo.MinimumSeverity)

## Executive Summary

- **Total Vulnerabilities**: $($ReportData.Summary.Total)
- **Critical**: $($ReportData.Summary.Critical)
- **High**: $($ReportData.Summary.High)
- **Medium**: $($ReportData.Summary.Medium)
- **Low**: $($ReportData.Summary.Low)

## Vulnerability Distribution by Source

- **GitHub Security Advisories**: $($ReportData.Sources.GitHub)
- **National Vulnerability Database**: $($ReportData.Sources.NVD)
- **Custom Rules**: $($ReportData.Sources.Custom)

## Critical Vulnerabilities

$(
    if ($ReportData.Summary.Critical -gt 0) {
        $criticalVulns = $ReportData.Vulnerabilities | Where-Object { $_.Severity -eq "Critical" }
        foreach ($vuln in $criticalVulns) {
            "### $($vuln.Package) v$($vuln.Version)"
            ""
            "- **ID**: $($vuln.ID)"
            "- **Source**: $($vuln.Source)"
            "- **CVSS Score**: $($vuln.CVSSScore)"
            "- **Description**: $($vuln.Description)"
            "- **Fixed in**: $($vuln.FixedInVersion)"
            "- **Published**: $($vuln.PublishedDate)"
            ""
        }
    } else {
        "No critical vulnerabilities found."
    }
)

## High Priority Vulnerabilities

$(
    if ($ReportData.Summary.High -gt 0) {
        $highVulns = $ReportData.Vulnerabilities | Where-Object { $_.Severity -eq "High" } | Select-Object -First 10
        foreach ($vuln in $highVulns) {
            "- **$($vuln.Package) v$($vuln.Version)**: $($vuln.ID) - $($vuln.Description)"
        }
        if (($ReportData.Vulnerabilities | Where-Object { $_.Severity -eq "High" }).Count -gt 10) {
            "... and $(($ReportData.Vulnerabilities | Where-Object { $_.Severity -eq "High" }).Count - 10) more"
        }
    } else {
        "No high priority vulnerabilities found."
    }
)

## Recommendations

1. **Immediate Action**: $(if ($ReportData.Summary.Critical -gt 0) { "Address all critical vulnerabilities immediately" } else { "No immediate critical threats detected" })
2. **Security Updates**: $(if ($ReportData.Summary.High -gt 0) { "Plan updates for high-severity vulnerabilities" } else { "No high-severity vulnerabilities found" })
3. **Monitoring**: Continue monitoring for new vulnerabilities in your dependencies

## Next Steps

1. Review and remediate all critical and high-severity vulnerabilities
2. Update affected packages to secure versions
3. Implement automated vulnerability scanning in your CI/CD pipeline
4. Set up monitoring for new vulnerability disclosures

---
*Report generated by TiXL Vulnerability Scanner v$($ReportData.ScanInfo.Version)*
"@
    
    $markdown | Out-File -FilePath $OutputPath -Encoding UTF8
}

# Main execution
Write-Log "Starting $script:ScriptName v$script:ScriptVersion" "INFO"
Write-Log "Project path: $ProjectPath" "INFO"
Write-Log "Minimum severity: $Severity" "INFO"

try {
    # Validate project structure
    Test-ProjectStructure -ProjectPath $ProjectPath
    
    # Get package list
    $packages = Get-PackageList -ProjectPath $ProjectPath
    
    if ($packages.Count -eq 0) {
        Write-Log "No packages found to scan" "WARNING"
        exit 1
    }
    
    # Scan all packages for vulnerabilities
    Write-Log "Scanning $($packages.Count) packages for vulnerabilities" "INFO"
    
    $allVulnerabilities = @()
    foreach ($package in $packages) {
        Write-Log "Scanning $($package.Name) v$($package.Version)" "INFO"
        
        $vulnerabilities = Test-VulnerabilityDatabases -PackageName $package.Name -Version $package.Version
        foreach ($vuln in $vulnerabilities) {
            $vuln | Add-Member -NotePropertyName "Project" -NotePropertyValue $package.Project -Force
        }
        
        $allVulnerabilities += $vulnerabilities
    }
    
    # Filter by severity
    $filteredVulnerabilities = Filter-VulnerabilitiesBySeverity -Vulnerabilities $allVulnerabilities -MinimumSeverity $Severity
    
    Write-Log "Found $($filteredVulnerabilities.Count) vulnerabilities at or above $Severity severity" "INFO"
    
    # Export reports
    Export-VulnerabilityReport -AllVulnerabilities $filteredVulnerabilities -OutputPath $OutputPath
    
    # Check for critical vulnerabilities
    $criticalCount = ($filteredVulnerabilities | Where-Object { $_.Severity -eq "Critical" }).Count
    $exitCode = 0
    
    if ($criticalCount -gt 0) {
        Write-Log "CRITICAL: Found $criticalCount critical vulnerabilities" "ERROR"
        
        if ($FailOnCritical) {
            Write-Log "Failing build due to critical vulnerabilities" "ERROR"
            $exitCode = 1
        }
    }
    
    Write-Log "=== VULNERABILITY SCAN COMPLETED ===" "INFO"
    Write-Log "Total vulnerabilities: $($filteredVulnerabilities.Count)" "INFO"
    Write-Log "Critical: $(($filteredVulnerabilities | Where-Object { $_.Severity -eq "Critical" }).Count)" "INFO"
    Write-Log "High: $(($filteredVulnerabilities | Where-Object { $_.Severity -eq "High" }).Count)" "INFO"
    Write-Log "Medium: $(($filteredVulnerabilities | Where-Object { $_.Severity -eq "Medium" }).Count)" "INFO"
    Write-Log "Low: $(($filteredVulnerabilities | Where-Object { $_.Severity -eq "Low" }).Count)" "INFO"
    
    exit $exitCode
}
catch {
    Write-Log "Vulnerability scan failed with error: $_" "ERROR"
    Write-Host "Error: $_" -ForegroundColor Red
    exit 1
}