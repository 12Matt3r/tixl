#!/usr/bin/env pwsh
<#
.SYNOPSIS
    TiXL Enhanced Vulnerability Scanner - Advanced security vulnerability detection with NVD and GitHub integration

.DESCRIPTION
    Advanced vulnerability scanner that integrates with:
    - National Vulnerability Database (NVD) API v2.0
    - GitHub Security Advisories API
    - Microsoft Security Response Center (MSRC)
    - Custom vulnerability databases
    
    Provides comprehensive vulnerability detection, severity assessment, and automated reporting.

.PARAMETER ProjectPath
    Path to the solution or project file to scan

.PARAMETER Severity
    Minimum vulnerability severity to report (Low, Medium, High, Critical)

.PARAMETER OutputPath
    Directory to save vulnerability reports

.PARAMETER FailOnCritical
    Exit with error code if critical vulnerabilities are found

.PARAMETER GitHubToken
    GitHub token for Security Advisories API access

.PARAMETER NVDApiKey
    API key for National Vulnerability Database

.EXAMPLE
    .\enhanced-vulnerability-scanner.ps1 -ProjectPath "TiXL.sln" -Severity "High" -GitHubToken $env:GITHUB_TOKEN

.EXAMPLE
    .\enhanced-vulnerability-scanner.ps1 -ProjectPath "TiXL.sln" -FailOnCritical -NVDApiKey $env:NVD_API_KEY
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory=$true)]
    [string]$ProjectPath,
    
    [Parameter(Mandatory=$false)]
    [ValidateSet("Low", "Medium", "High", "Critical")]
    [string]$Severity = "Medium",
    
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "./enhanced-vulnerability-reports",
    
    [Parameter(Mandatory=$false)]
    [switch]$FailOnCritical,
    
    [Parameter(Mandatory=$false)]
    [string]$GitHubToken = $env:GITHUB_TOKEN,
    
    [Parameter(Mandatory=$false)]
    [string]$NVDApiKey = $env:NVD_API_KEY,
    
    [Parameter(Mandatory=$false)]
    [switch]$IncludeMSRC,
    
    [Parameter(Mandatory=$false)]
    [switch]$GenerateSBOM,
    
    [Parameter(Mandatory=$false)]
    [switch]$EnableRealTimeScanning
)

# Global variables
$script:ScriptName = "TiXL Enhanced Vulnerability Scanner"
$script:ScriptVersion = "2.0.0"
$script:StartTime = Get-Date
$script:ConfigPath = "$PSScriptRoot\..\config\vulnerability-rules.json"
$script:CachePath = Join-Path $OutputPath "cache"

# Initialize output directories
if (!(Test-Path $OutputPath)) {
    New-Item -Path $OutputPath -ItemType Directory -Force | Out-Null
}
if (!(Test-Path $script:CachePath)) {
    New-Item -Path $script:CachePath -ItemType Directory -Force | Out-Null
}

$script:LogFile = Join-Path $OutputPath "enhanced-vulnerability-scan.log"
$script:ReportFile = Join-Path $OutputPath "enhanced-vulnerability-report.json"
$script:SummaryFile = Join-Path $OutputPath "vulnerability-summary.md"
$script:SBOMFile = Join-Path $OutputPath "sbom.json"

# Severity weights for filtering
$script:SeverityWeights = @{
    "Critical" = 4
    "High" = 3
    "Medium" = 2
    "Low" = 1
}

# CVSS v3.1 severity thresholds
$script:CVSSThresholds = @{
    "Critical" = 9.0
    "High" = 7.0
    "Medium" = 4.0
    "Low" = 0.1
}

function Write-Log {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Message,
        [Parameter(Mandatory=$false)]
        [ValidateSet("INFO", "WARNING", "ERROR", "DEBUG")]
        [string]$Level = "INFO"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    
    if ($Level -ne "DEBUG" -or $Verbose) {
        Write-Host $logEntry
    }
    
    $logEntry | Out-File -FilePath $script:LogFile -Append -Encoding UTF8
}

function Test-Prerequisites {
    Write-Log "Checking prerequisites and dependencies" "INFO"
    
    # Check .NET SDK
    try {
        $dotnetVersion = dotnet --version
        Write-Log "âœ… .NET SDK: $dotnetVersion" "INFO"
    } catch {
        Write-Log "âŒ .NET SDK not found" "ERROR"
        return $false
    }
    
    # Check PowerShell version
    $psVersion = $PSVersionTable.PSVersion
    if ($psVersion.Major -lt 7) {
        Write-Log "âš ï¸  PowerShell 7+ recommended, current: $($psVersion.ToString())" "WARNING"
    }
    
    # Test network connectivity
    $networkTest = Test-Connection -ComputerName "api.nuget.org" -Count 1 -Quiet
    if (-not $networkTest) {
        Write-Log "âš ï¸  Network connectivity issues detected" "WARNING"
    }
    
    return $true
}

function Get-PackageInventory {
    param([string]$ProjectPath)
    
    Write-Log "Extracting comprehensive package inventory from $ProjectPath" "INFO"
    
    $packages = @()
    
    try {
        # Use dotnet to get detailed package information
        $listOutput = dotnet list "$ProjectPath" package --include-transitive --format json 2>&1
        
        if ($LASTEXITCODE -eq 0 -and $listOutput) {
            $packageData = $listOutput | ConvertFrom-Json
            
            # Process projects and their dependencies
            foreach ($project in $packageData.projects) {
                $projectName = $project.name
                Write-Log "Processing project: $projectName" "DEBUG"
                
                if ($project.frameworks) {
                    foreach ($framework in $project.frameworks) {
                        foreach ($dependency in $framework.dependencies) {
                            if ($dependency.type -eq "package") {
                                $package = [PSCustomObject]@{
                                    Name = $dependency.name
                                    Version = $dependency.version
                                    TargetFramework = $framework.frameworkName
                                    Project = $projectName
                                    ProjectPath = $ProjectPath
                                    Source = "nuget"
                                    Type = "direct"
                                    LicenseUrl = $dependency.licenseUrl
                                    Description = $dependency.description
                                }
                                $packages += $package
                            }
                        }
                    }
                }
            }
            
            # Also include transitive dependencies if available
            if ($packageData.transitiveDependencies) {
                foreach ($transitiveDep in $packageData.transitiveDependencies) {
                    $package = [PSCustomObject]@{
                        Name = $transitiveDep.name
                        Version = $transitiveDep.version
                        TargetFramework = "transitive"
                        Project = "transitive"
                        ProjectPath = $ProjectPath
                        Source = "nuget"
                        Type = "transitive"
                        LicenseUrl = $transitiveDep.licenseUrl
                        Description = $transitiveDep.description
                    }
                    $packages += $package
                }
            }
        }
        else {
            Write-Log "Failed to get package list using dotnet list" "WARNING"
            # Fallback to basic extraction
            $packages = Get-PackagesBasic -ProjectPath $ProjectPath
        }
    }
    catch {
        Write-Log "Error getting package inventory: $_" "ERROR"
        # Fallback to basic extraction
        $packages = Get-PackagesBasic -ProjectPath $ProjectPath
    }
    
    Write-Log "Found $($packages.Count) packages to scan" "INFO"
    return $packages | Sort-Object -Property Name, Version -Unique
}

function Get-PackagesBasic {
    param([string]$ProjectPath)
    
    $packages = @()
    
    try {
        $listOutput = dotnet list "$ProjectPath" package --include-transitive 2>$null
        
        foreach ($line in $listOutput) {
            if ($line -match "^\s*([\w\.-]+)\s+([\d\.]+)\s+(.*)$") {
                $packageName = $matches[1]
                $version = $matches[2]
                $license = $matches[3]
                
                $package = [PSCustomObject]@{
                    Name = $packageName
                    Version = $version
                    TargetFramework = "unknown"
                    Project = "unknown"
                    ProjectPath = $ProjectPath
                    Source = "nuget"
                    Type = "unknown"
                    LicenseUrl = $license
                    Description = ""
                }
                $packages += $package
            }
        }
    }
    catch {
        Write-Log "Error in basic package extraction: $_" "ERROR"
    }
    
    return $packages
}

function Test-GitHubSecurityAdvisories {
    param(
        [string]$PackageName,
        [string]$Version
    )
    
    $vulnerabilities = @()
    
    try {
        if (-not $GitHubToken) {
            Write-Log "GitHub token not provided, skipping GitHub Security Advisories" "WARNING"
            return $vulnerabilities
        }
        
        Write-Log "Checking GitHub Security Advisories for $PackageName v$Version" "DEBUG"
        
        # GitHub Security Advisories API v2
        $apiUrl = "https://api.github.com/advisories?package_name=$PackageName&package_ecosystem=NUGET&per_page=100"
        
        $headers = @{
            "Accept" = "application/vnd.github+json"
            "Authorization" = "Bearer $GitHubToken"
            "User-Agent" = "TiXL-Vulnerability-Scanner/2.0"
            "X-GitHub-Api-Version" = "2022-11-28"
        }
        
        $response = Invoke-RestMethod -Uri $apiUrl -Headers $headers -Method Get -ErrorAction SilentlyContinue
        
        if ($response -and $response.data) {
            foreach ($advisory in $response.data) {
                # Check if version is affected
                if (Test-VersionAffected -CurrentVersion $Version -VulnerableRange $advisory.vulnerable_version_range) {
                    $severity = Convert-GHSeverityToStandard $advisory.severity
                    
                    $vulnerability = [PSCustomObject]@{
                        ID = $advisory.ghsa_id
                        Source = "GitHub Security Advisories"
                        Severity = $severity
                        CVSSScore = $advisory.cvss?.score
                        CVSSVector = $advisory.cvss?.vector_string
                        Description = $advisory.summary
                        FixedInVersion = $advisory.first_patched_version
                        PublishedDate = $advisory.published_at
                        UpdatedDate = $advisory.updated_at
                        Package = $PackageName
                        Version = $Version
                        CVEs = $advisory.cves
                        References = $advisory.permalinks
                        EPSS = $advisory.epss_score
                        SeverityDistribution = $advisory.severity_distribution
                        IdentifiedVia = $advisory.identifiers
                        Credits = $advisory.credits
                    }
                    
                    $vulnerabilities += $vulnerability
                }
            }
        }
    }
    catch {
        Write-Log "Error checking GitHub Security Advisories: $_" "WARNING"
    }
    
    return $vulnerabilities
}

function Test-NVDVulnerabilities {
    param(
        [string]$PackageName,
        [string]$Version
    )
    
    $vulnerabilities = @()
    
    try {
        Write-Log "Checking NVD for $PackageName v$Version" "DEBUG"
        
        # NVD API v2.0 with improved search
        $searchTerms = "$PackageName package nuget"
        $apiUrl = "https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=$([System.Web.HttpUtility]::UrlEncode($searchTerms))&resultsPerPage=50"
        
        $headers = @{}
        if ($NVDApiKey) {
            $headers["apiKey"] = $NVDApiKey
        }
        
        $response = Invoke-RestMethod -Uri $apiUrl -Headers $headers -Method Get -ErrorAction SilentlyContinue
        
        if ($response -and $response.vulnerabilities) {
            foreach ($vulnData in $response.vulnerabilities) {
                $cve = $vulnData.cve
                
                # Enhanced CVE analysis
                if (Test-CVEAffectsPackage -CVE $cve -PackageName $PackageName -Version $Version) {
                    $cvssScore = Get-CVSSScore -Metrics $cve.metrics
                    $severity = Get-SeverityFromCVSS -Score $cvssScore
                    
                    $vulnerability = [PSCustomObject]@{
                        ID = $cve.id
                        Source = "National Vulnerability Database"
                        Severity = $severity
                        CVSSScore = $cvssScore
                        CVSSVector = Get-CVSSVector -Metrics $cve.metrics
                        Description = Get-CVEDescription -Descriptions $cve.descriptions
                        FixedInVersion = $null  # NVD doesn't always provide fix versions
                        PublishedDate = $cve.published
                        UpdatedDate = $cve.lastModified
                        Package = $PackageName
                        Version = $Version
                        CVEs = @($cve.id)
                        References = $cve.references
                        Weaknesses = $cve.weaknesses
                        Configurations = $cve.configurations
                        Impact = $cve.impact
                    }
                    
                    $vulnerabilities += $vulnerability
                }
            }
        }
    }
    catch {
        Write-Log "Error checking NVD: $_" "WARNING"
    }
    
    return $vulnerabilities
}

function Test-MSRC {
    param(
        [string]$PackageName,
        [string]$Version
    )
    
    $vulnerabilities = @()
    
    try {
        Write-Log "Checking MSRC for Microsoft packages: $PackageName" "DEBUG"
        
        # Check if this is a Microsoft package
        if ($PackageName -notmatch "^(Microsoft|Microsoft\.|[A-Za-z]+\.Microsoft\.)") {
            return $vulnerabilities
        }
        
        # MSRC API v2
        $currentYear = (Get-Date).Year
        $apiUrl = "https://api.msrc.microsoft.com/summary/v2.0"
        
        $response = Invoke-RestMethod -Uri $apiUrl -ErrorAction SilentlyContinue
        
        if ($response -and $response.Items) {
            # This is a simplified implementation
            # Real implementation would search through Microsoft security updates
            Write-Log "MSRC check completed for Microsoft package: $PackageName" "DEBUG"
        }
    }
    catch {
        Write-Log "Error checking MSRC: $_" "WARNING"
    }
    
    return $vulnerabilities
}

function Get-EnhancedCVSSAnalysis {
    param($Metrics)
    
    $analysis = @{
        BaseScore = 0.0
        Vector = ""
        Severity = "Unknown"
        BaseSeverity = "Unknown"
        TemporalScore = 0.0
        EnvironmentalScore = 0.0
    }
    
    try {
        # CVSS v3.1
        if ($Metrics.cvssMetricV31 -and $Metrics.cvssMetricV31.Count -gt 0) {
            $cvss = $Metrics.cvssMetricV31[0].cvssData
            $analysis.BaseScore = $cvss.baseScore
            $analysis.Vector = $cvss.vectorString
            $analysis.BaseSeverity = $cvss.baseSeverity
            $analysis.TemporalScore = $Metrics.cvssMetricV31[0].temporalScore
            $analysis.EnvironmentalScore = $Metrics.cvssMetricV31[0].environmentalScore
        }
        # CVSS v3.0
        elseif ($Metrics.cvssMetricV30 -and $Metrics.cvssMetricV30.Count -gt 0) {
            $cvss = $Metrics.cvssMetricV30[0].cvssData
            $analysis.BaseScore = $cvss.baseScore
            $analysis.Vector = $cvss.vectorString
            $analysis.BaseSeverity = $cvss.baseSeverity
        }
        # CVSS v2.0 (legacy)
        elseif ($Metrics.cvssMetricV2 -and $Metrics.cvssMetricV2.Count -gt 0) {
            $cvss = $Metrics.cvssMetricV2[0].cvssData
            $analysis.BaseScore = $cvss.baseScore
            $analysis.Vector = $cvss.vectorString
        }
        
        $analysis.Severity = Get-SeverityFromCVSS -Score $analysis.BaseScore
    }
    catch {
        Write-Log "Error analyzing CVSS metrics: $_" "WARNING"
    }
    
    return $analysis
}

function Test-VersionAffected {
    param(
        [string]$CurrentVersion,
        [string]$VulnerableRange
    )
    
    # Enhanced version range checking
    if ([string]::IsNullOrWhiteSpace($VulnerableRange) -or $VulnerableRange -eq "*") {
        return $true
    }
    
    # Handle different range formats
    $ranges = $VulnerableRange -split '\|\|'
    foreach ($range in $ranges) {
        if (Test-SingleVersionRange -CurrentVersion $CurrentVersion -Range $range) {
            return $true
        }
    }
    
    return $false
}

function Test-SingleVersionRange {
    param(
        [string]$CurrentVersion,
        [string]$Range
    )
    
    $Range = $Range.Trim()
    
    # Handle exact version match
    if ($Range -eq $CurrentVersion) {
        return $true
    }
    
    # Handle ">= 1.0.0 < 2.0.0" style ranges
    if ($Range -match "([<>]=?)\s*([\d\.]+)(?:\s*([<>]=?)\s*([\d\.]+))?") {
        $operator1 = $matches[1]
        $version1 = $matches[2]
        $operator2 = $matches[3]
        $version2 = $matches[4]
        
        try {
            $currentVer = [version]$CurrentVersion
            $ver1 = [version]$version1
            $ver2 = if ($version2) { [version]$version2 } else { $null }
            
            # Check first condition
            $pass1 = switch ($operator1) {
                ">="  { $currentVer -ge $ver1 }
                ">"   { $currentVer -gt $ver1 }
                "<="  { $currentVer -le $ver1 }
                "<"   { $currentVer -lt $ver1 }
                default { $false }
            }
            
            if (-not $pass1) { return $false }
            
            # Check second condition if present
            if ($ver2 -and $operator2) {
                $pass2 = switch ($operator2) {
                    ">="  { $currentVer -ge $ver2 }
                    ">"   { $currentVer -gt $ver2 }
                    "<="  { $currentVer -le $ver2 }
                    "<"   { $currentVer -lt $ver2 }
                    default { $true }
                }
                return $pass2
            }
            
            return $true
        }
        catch {
            Write-Log "Error parsing version range: $Range" "WARNING"
        }
    }
    
    # Handle prefix ranges like "1.0.*" or "1.0"
    if ($Range -match "^([\d\.]+)\.\*$") {
        $prefix = $matches[1]
        return $CurrentVersion -like "$prefix.*"
    }
    
    return $false
}

function GenerateSBOM {
    param(
        [array]$Packages,
        [string]$OutputPath
    )
    
    Write-Log "Generating Software Bill of Materials (SBOM)" "INFO"
    
    $bom = @{
        bomFormat = "CycloneDX"
        specVersion = "1.4"
        serialNumber = "urn:uuid:$([System.Guid]::NewGuid().ToString())"
        version = 1
        timestamp = (Get-Date).ToUniversalTime()
        metadata = @{
            tools = @(
                @{
                    vendor = "TiXL"
                    name = "Enhanced Vulnerability Scanner"
                    version = $script:ScriptVersion
                }
            )
            component = @{
                type = "application"
                bomRef = "tixl-application"
                name = "TiXL"
                version = "1.0.0"
            }
        }
        components = @()
        dependencies = @()
    }
    
    foreach ($package in $Packages) {
        $component = @{
            type = "library"
            bomRef = "$($package.Name)-$($package.Version)"
            name = $package.Name
            version = $package.Version
            publisher = "unknown"
            licenses = @()
            externalReferences = @()
        }
        
        if ($package.LicenseUrl) {
            $component.licenses += @{
                expression = $package.LicenseUrl
            }
        }
        
        if ($package.Description) {
            $component.description = $package.Description
        }
        
        $bom.components += $component
    }
    
    # Save SBOM
    $sbomJson = $bom | ConvertTo-Json -Depth 10
    $sbomJson | Out-File -FilePath $OutputPath -Encoding UTF8
    
    Write-Log "SBOM generated: $OutputPath" "INFO"
}

function Export-EnhancedReport {
    param(
        [array]$AllVulnerabilities,
        [array]$Packages,
        [string]$OutputPath
    )
    
    Write-Log "Exporting enhanced vulnerability report" "INFO"
    
    $summary = @{
        TotalVulnerabilities = $AllVulnerabilities.Count
        Critical = ($AllVulnerabilities | Where-Object { $_.Severity -eq "Critical" }).Count
        High = ($AllVulnerabilities | Where-Object { $_.Severity -eq "High" }).Count
        Medium = ($AllVulnerabilities | Where-Object { $_.Severity -eq "Medium" }).Count
        Low = ($AllVulnerabilities | Where-Object { $_.Severity -eq "Low" }).Count
        UniquePackages = $Packages.Count
        VulnerablePackages = ($AllVulnerabilities | Select-Object -ExpandProperty Package -Unique).Count
        AvgCVSSScore = if ($AllVulnerabilities) { 
            ($AllVulnerabilities | Where-Object { $_.CVSSScore } | Measure-Object -Property CVSSScore -Average).Average 
        } else { 0 }
    }
    
    $reportData = @{
        ScanInfo = @{
            Timestamp = $script:StartTime
            Duration = (Get-Date) - $script:StartTime
            Version = $script:ScriptVersion
            ProjectPath = $ProjectPath
            MinimumSeverity = $Severity
            Environment = @{
                OS = $PSVersionTable.OS
                PowerShell = $PSVersionTable.PSVersion.ToString()
                DotNet = (dotnet --version)
                WorkingDirectory = Get-Location
            }
        }
        Summary = $summary
        Vulnerabilities = $AllVulnerabilities
        Packages = $Packages
        Sources = @{
            GitHub = ($AllVulnerabilities | Where-Object { $_.Source -eq "GitHub Security Advisories" }).Count
            NVD = ($AllVulnerabilities | Where-Object { $_.Source -eq "National Vulnerability Database" }).Count
            MSRC = ($AllVulnerabilities | Where-Object { $_.Source -eq "Microsoft Security Response Center" }).Count
            Custom = ($AllVulnerabilities | Where-Object { $_.Source -eq "Custom Rule" }).Count
        }
        Recommendations = Get-SecurityRecommendations -Vulnerabilities $AllVulnerabilities
        RiskScore = CalculateRiskScore -Summary $summary
    }
    
    # Export JSON report
    $reportData | ConvertTo-Json -Depth 15 | Out-File -FilePath $script:ReportFile -Encoding UTF8
    
    # Generate markdown summary
    Export-EnhancedMarkdownSummary -ReportData $reportData -OutputPath $script:SummaryFile
    
    # Generate SBOM if requested
    if ($GenerateSBOM) {
        GenerateSBOM -Packages $Packages -OutputPath $script:SBOMFile
    }
    
    Write-Log "Enhanced vulnerability report exported to: $OutputPath" "INFO"
}

function Get-SecurityRecommendations {
    param([array]$Vulnerabilities)
    
    $recommendations = @()
    
    # Critical vulnerabilities
    $criticalVulns = $Vulnerabilities | Where-Object { $_.Severity -eq "Critical" }
    if ($criticalVulns.Count -gt 0) {
        $recommendations += @{
            Priority = "Critical"
            Action = "Immediate remediation required"
            Details = "Address all critical vulnerabilities within 24 hours"
            Vulnerabilities = $criticalVulns.Count
            Packages = ($criticalVulns | Select-Object -ExpandProperty Package -Unique).Count
        }
    }
    
    # High vulnerabilities
    $highVulns = $Vulnerabilities | Where-Object { $_.Severity -eq "High" }
    if ($highVulns.Count -gt 0) {
        $recommendations += @{
            Priority = "High"
            Action = "Schedule immediate attention"
            Details = "Plan remediation within 1 week"
            Vulnerabilities = $highVulns.Count
            Packages = ($highVulns | Select-Object -ExpandProperty Package -Unique).Count
        }
    }
    
    # Package updates available
    $packagesWithFixes = $Vulnerabilities | Where-Object { $_.FixedInVersion }
    if ($packagesWithFixes.Count -gt 0) {
        $recommendations += @{
            Priority = "Medium"
            Action = "Update packages with available fixes"
            Details = "$($packagesWithFixes.Count) packages have security fixes available"
            Vulnerabilities = $packagesWithFixes.Count
            Packages = ($packagesWithFixes | Select-Object -ExpandProperty Package -Unique).Count
        }
    }
    
    return $recommendations
}

function CalculateRiskScore {
    param($Summary)
    
    # Weighted risk calculation
    $riskScore = 0
    
    $riskScore += $Summary.Critical * 10
    $riskScore += $Summary.High * 7
    $riskScore += $Summary.Medium * 4
    $riskScore += $Summary.Low * 1
    
    # Normalize to 0-100 scale
    $maxPossibleRisk = $Summary.UniquePackages * 10
    $normalizedScore = if ($maxPossibleRisk -gt 0) { 
        [Math]::Max(0, 100 - (($riskScore / $maxPossibleRisk) * 100))
    } else { 100 }
    
    return [Math]::Round($normalizedScore, 2)
}

function Export-EnhancedMarkdownSummary {
    param(
        $ReportData,
        [string]$OutputPath
    )
    
    $markdown = @"
# TiXL Enhanced Vulnerability Scan Report

**Generated**: $($ReportData.ScanInfo.Timestamp.ToString("yyyy-MM-dd HH:mm:ss UTC"))
**Duration**: $($ReportData.ScanInfo.Duration.TotalSeconds.ToString("F2")) seconds
**Scanner Version**: $($ReportData.ScanInfo.Version)

## Executive Summary

| Metric | Value |
|--------|-------|
| **Total Vulnerabilities** | $($ReportData.Summary.TotalVulnerabilities) |
| **Critical** | $($ReportData.Summary.Critical) |
| **High** | $($ReportData.Summary.High) |
| **Medium** | $($ReportData.Summary.Medium) |
| **Low** | $($ReportData.Summary.Low) |
| **Unique Packages Scanned** | $($ReportData.Summary.UniquePackages) |
| **Vulnerable Packages** | $($ReportData.Summary.VulnerablePackages) |
| **Average CVSS Score** | $($ReportData.Summary.AvgCVSSScore.ToString("F2")) |
| **Security Risk Score** | $($ReportData.RiskScore)/100 |

## Vulnerability Distribution by Source

- **GitHub Security Advisories**: $($ReportData.Sources.GitHub)
- **National Vulnerability Database**: $($ReportData.Sources.NVD)
- **Microsoft Security Response Center**: $($ReportData.Sources.MSRC)
- **Custom Rules**: $($ReportData.Sources.Custom)

## Security Recommendations

$(
    if ($ReportData.Recommendations.Count -gt 0) {
        foreach ($rec in $ReportData.Recommendations) {
            "### $($rec.Priority) Priority"
            ""
            "- **Action**: $($rec.Action)"
            "- **Details**: $($rec.Details)"
            "- **Affected Vulnerabilities**: $($rec.Vulnerabilities)"
            "- **Affected Packages**: $($rec.Packages)"
            ""
        }
    } else {
        "No immediate security recommendations. Your dependency health looks good!"
    }
)

## Critical Vulnerabilities Requiring Immediate Action

$(
    $criticalVulns = $ReportData.Vulnerabilities | Where-Object { $_.Severity -eq "Critical" }
    if ($criticalVulns.Count -gt 0) {
        foreach ($vuln in $criticalVulns) {
            "### $($vuln.Package) v$($vuln.Version)"
            ""
            "- **Vulnerability ID**: $($vuln.ID)"
            "- **Source**: $($vuln.Source)"
            "- **CVSS Score**: $($vuln.CVSSScore)"
            "- **CVSS Vector**: $($vuln.CVSSVector)"
            "- **Description**: $($vuln.Description)"
            "- **Fixed in Version**: $($vuln.FixedInVersion)"
            "- **Published**: $($vuln.PublishedDate)"
            "- **CVEs**: $($vuln.CVEs -join ", ")"
            ""
        }
    } else {
        "âœ… **No critical vulnerabilities found.**"
    }
)

## High Priority Vulnerabilities

$(
    $highVulns = $ReportData.Vulnerabilities | Where-Object { $_.Severity -eq "High" } | Select-Object -First 10
    if ($highVulns.Count -gt 0) {
        foreach ($vuln in $highVulns) {
            "- **$($vuln.Package) v$($vuln.Version)**: $($vuln.ID) - $($vuln.Description)"
        }
        $remainingHigh = ($ReportData.Vulnerabilities | Where-Object { $_.Severity -eq "High" }).Count - 10
        if ($remainingHigh -gt 0) {
            "- ... and $remainingHigh more high-priority vulnerabilities"
        }
    } else {
        "No high-priority vulnerabilities found."
    }
)

## Package Health Overview

| Status | Count |
|--------|-------|
| Vulnerable Packages | $($ReportData.Summary.VulnerablePackages) |
| Healthy Packages | $($ReportData.Summary.UniquePackages - $ReportData.Summary.VulnerablePackages) |
| Packages with Available Fixes | $($ReportData.Vulnerabilities | Where-Object { $_.FixedInVersion } | Select-Object -ExpandProperty Package -Unique).Count |

## Next Steps

1. **Immediate**: Address all critical vulnerabilities within 24 hours
2. **This Week**: Plan remediation for high-severity vulnerabilities  
3. **This Month**: Review and update medium-severity vulnerabilities
4. **Ongoing**: Monitor for new vulnerabilities and set up automated scanning

## Environment Information

- **Operating System**: $($ReportData.ScanInfo.Environment.OS)
- **PowerShell Version**: $($ReportData.ScanInfo.Environment.PowerShell)
- **.NET Version**: $($ReportData.ScanInfo.Environment.DotNet)
- **Working Directory**: $($ReportData.ScanInfo.Environment.WorkingDirectory)

---
*Report generated by TiXL Enhanced Vulnerability Scanner v$($ReportData.ScanInfo.Version)*
"@
    
    $markdown | Out-File -FilePath $OutputPath -Encoding UTF8
}

# Main execution
Write-Log "Starting $script:ScriptName v$script:ScriptVersion" "INFO"
Write-Log "Project path: $ProjectPath" "INFO"
Write-Log "Minimum severity: $Severity" "INFO"
Write-Log "GitHub integration: $(if ($GitHubToken) { 'Enabled' } else { 'Disabled' })" "INFO"
Write-Log "NVD API: $(if ($NVDApiKey) { 'Enabled' } else { 'Disabled' })" "INFO"
Write-Log "MSRC integration: $(if ($IncludeMSRC) { 'Enabled' } else { 'Disabled' })" "INFO"

try {
    # Check prerequisites
    if (-not (Test-Prerequisites)) {
        Write-Log "Prerequisites check failed" "ERROR"
        exit 1
    }
    
    # Get comprehensive package inventory
    $packages = Get-PackageInventory -ProjectPath $ProjectPath
    
    if ($packages.Count -eq 0) {
        Write-Log "No packages found to scan" "WARNING"
        exit 1
    }
    
    # Scan all packages for vulnerabilities
    Write-Log "Scanning $($packages.Count) packages for vulnerabilities" "INFO"
    
    $allVulnerabilities = @()
    foreach ($package in $packages) {
        Write-Log "Scanning $($package.Name) v$($package.Version)" "INFO"
        
        $vulnerabilities = @()
        
        # Test all vulnerability sources
        $vulnerabilities += Test-GitHubSecurityAdvisories -PackageName $package.Name -Version $package.Version
        $vulnerabilities += Test-NVDVulnerabilities -PackageName $package.Name -Version $package.Version
        
        if ($IncludeMSRC) {
            $vulnerabilities += Test-MSRC -PackageName $package.Name -Version $package.Version
        }
        
        # Add project information to vulnerabilities
        foreach ($vuln in $vulnerabilities) {
            $vuln | Add-Member -NotePropertyName "Project" -NotePropertyValue $package.Project -Force
            $vuln | Add-Member -NotePropertyName "TargetFramework" -NotePropertyValue $package.TargetFramework -Force
        }
        
        $allVulnerabilities += $vulnerabilities
    }
    
    # Filter by severity
    $minimumWeight = $script:SeverityWeights[$Severity]
    $filteredVulnerabilities = $allVulnerabilities | Where-Object {
        $script:SeverityWeights[$_.Severity] -ge $minimumWeight
    }
    
    Write-Log "Found $($filteredVulnerabilities.Count) vulnerabilities at or above $Severity severity" "INFO"
    
    # Export comprehensive reports
    Export-EnhancedReport -AllVulnerabilities $filteredVulnerabilities -Packages $packages -OutputPath $OutputPath
    
    # Check for critical vulnerabilities and exit appropriately
    $criticalCount = ($filteredVulnerabilities | Where-Object { $_.Severity -eq "Critical" }).Count
    $highCount = ($filteredVulnerabilities | Where-Object { $_.Severity -eq "High" }).Count
    $exitCode = 0
    
    if ($criticalCount -gt 0) {
        Write-Log "ğŸš¨ CRITICAL: Found $criticalCount critical vulnerabilities" "ERROR"
        Write-Log "Critical vulnerabilities require immediate attention" "ERROR"
        
        if ($FailOnCritical) {
            Write-Log "Failing build due to critical vulnerabilities" "ERROR"
            $exitCode = 1
        }
    }
    
    if ($highCount -gt 0) {
        Write-Log "âš ï¸  WARNING: Found $highCount high-severity vulnerabilities" "WARNING"
        Write-Log "High-severity vulnerabilities should be addressed soon" "WARNING"
    }
    
    Write-Log "=== ENHANCED VULNERABILITY SCAN COMPLETED ===" "INFO"
    Write-Log "Total vulnerabilities: $($filteredVulnerabilities.Count)" "INFO"
    Write-Log "Critical: $(($filteredVulnerabilities | Where-Object { $_.Severity -eq "Critical" }).Count)" "INFO"
    Write-Log "High: $(($filteredVulnerabilities | Where-Object { $_.Severity -eq "High" }).Count)" "INFO"
    Write-Log "Medium: $(($filteredVulnerabilities | Where-Object { $_.Severity -eq "Medium" }).Count)" "INFO"
    Write-Log "Low: $(($filteredVulnerabilities | Where-Object { $_.Severity -eq "Low" }).Count)" "INFO"
    
    # Generate summary statistics for output
    Write-Host "`nğŸ“Š Scan Summary" -ForegroundColor Cyan
    Write-Host "===============" -ForegroundColor Cyan
    Write-Host "Packages scanned: $($packages.Count)" -ForegroundColor White
    Write-Host "Vulnerabilities found: $($filteredVulnerabilities.Count)" -ForegroundColor $(if ($filteredVulnerabilities.Count -eq 0) { "Green" } else { "Yellow" })
    Write-Host "Critical: $(($filteredVulnerabilities | Where-Object { $_.Severity -eq "Critical" }).Count)" -ForegroundColor $(if ($criticalCount -gt 0) { "Red" } else { "Green" })
    Write-Host "High: $highCount" -ForegroundColor $(if ($highCount -gt 0) { "Yellow" } else { "Green" })
    Write-Host "Reports saved to: $OutputPath" -ForegroundColor Blue
    
    exit $exitCode
}
catch {
    Write-Log "Enhanced vulnerability scan failed with error: $_" "ERROR"
    Write-Host "Error: $_" -ForegroundColor Red
    exit 1
}